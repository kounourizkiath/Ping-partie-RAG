Source: https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
Scraped: 2025-12-22 20:48:05
================================================================================

Deserialization - OWASP Cheat Sheet Series
Deserialization Cheat Sheet
This article is focused on providing clear, actionable guidance for safely deserializing untrusted data in your applications.
What is Deserialization
is the process of turning some object into a data format that can be restored later. People often serialize objects in order to save them for storage, or to send as part of communications.
is the reverse of that process, taking data structured in some format, and rebuilding it into an object. Today, the most popular data format for serializing data is JSON. Before that, it was XML.
However, many programming languages have native ways to serialize objects. These native formats usually offer more features than JSON or XML, including customization of the serialization process.
Unfortunately, the features of these native deserialization mechanisms can sometimes be repurposed for malicious effect when operating on untrusted data. Attacks against deserializers have been found to allow denial-of-service, access control, or remote code execution (RCE) attacks.
Guidance on Deserializing Objects Safely
The following language-specific guidance attempts to enumerate safe methodologies for deserializing data that can't be trusted.
function and review how the external parameters are accepted. Use a safe, standard data interchange format such as JSON (via
) if you need to pass serialized data to the user.
If the traffic data contains the symbol dot
at the end, it's very likely that the data was sent in serialization. It will be only true if the data is not being encoded using Base64 or Hexadecimal schemas. If the data is being encoded, then it's best to check if the serialization is likely happening or not by looking at the starting characters of the parameter value. For example if data is Base64 encoded, then it will most likely start with
The following API in Python will be vulnerable to serialization attack. Search code for the pattern below.
pickle/c_pickle/_pickle
""" cos.system(S'dir')tR. """
"!!python/object/apply:os.system ['ipconfig']"
The following techniques are all good for preventing attacks against deserialization against
Java's Serializable format
Implementation advice:
In your code, override the
ObjectInputStream#resolveClass()
method to prevent arbitrary classes from being deserialized. This safe behavior can be wrapped in a library like
Use a safe replacement for the generic
method as seen here. Note that this addresses "
" type attacks by checking input length and number of objects deserialized.
Be aware of the following Java API uses for potential serialization vulnerability.
with external user defined parameters
method (xstream version <= v1.4.6 is vulnerable to the serialization issue)
ObjectInputStream.readUnshared
If the captured traffic data includes the following patterns, it may suggest that the data was sent in Java serialization streams:
header of an HTTP response set to
application/x-java-serialized-object
Prevent Data Leakage and Trusted Field Clobbering
If there are data members of an object that should never be controlled by end users during deserialization or exposed to users during serialization, they should be declared as
Protecting Sensitive Information
For a class that defined as Serializable, the sensitive information variable should be declared as
For example, the class
, the variables 'profit' and 'margin' were declared as transient to prevent them from being serialized.
// declared transient
// declared transient
Prevent Deserialization of Domain Objects
Some of your application objects may be forced to implement
due to their hierarchy. To guarantee that your application objects can't be deserialized, a
method should be declared (with a
modifier) which always throws an exception:
"Cannot be deserialized"
Harden Your Own java.io.ObjectInputStream
java.io.ObjectInputStream
class is used to deserialize objects. It's possible to harden its behavior by subclassing it. This is the best solution if:
you can change the code that does the deserialization;
you know what classes you expect to deserialize.
The general idea is to override
ObjectInputStream.html#resolveClass()
in order to restrict which classes are allowed to be deserialized.
Because this call happens before a
is called, you can be sure that no deserialization activity will occur unless the type is one that you allow.
A simple example is shown here, where the
LookAheadObjectInputStream
class is guaranteed to
deserialize any other type besides the
LookAheadObjectInputStream
LookAheadObjectInputStream
* Only deserialize instances of our expected Bicycle class
ClassNotFoundException
InvalidClassException
"Unauthorized deserialization attempt"
More complete implementations of this approach have been proposed by various community members:
- a library that allows creating lists of classes that are allowed to be deserialized
- the seminal protection, written years before the most devastating exploitation scenarios were envisioned.
Apache Commons IO classes
Harden All java.io.ObjectInputStream Usage with an Agent
As mentioned above, the
java.io.ObjectInputStream
class is used to deserialize objects. It's possible to harden its behavior by subclassing it. However, if you don't own the code or can't wait for a patch, using an agent to weave in hardening to
java.io.ObjectInputStream
is the best solution.
is only safe for block-listing known malicious types, because it's not possible to know for all applications what the expected classes to be deserialized are. Fortunately, there are very few classes needed in the denylist to be safe from all the known attack vectors, today.
It's inevitable that more "gadget" classes will be discovered that can be abused. However, there is an incredible amount of vulnerable software exposed today, in need of a fix. In some cases, "fixing" the vulnerability may involve re-architecting messaging systems and breaking backwards compatibility as developers move towards not accepting serialized objects.
To enable these agents, simply add a new JVM parameter:
-javaagent:name-of-agent.jar
Agents taking this approach have been released by various community members:
rO0 by Contrast Security
A similar, but less scalable approach would be to manually patch and bootstrap your JVM's ObjectInputStream. Guidance on this approach is available
Other Deserialization Libraries and Formats
While the advice above is focused on
Java's Serializable format
, there are a number of other libraries
that use other formats for deserialization. Many of these libraries may have similar security
issues if not configured correctly. This section lists some of these libraries and
recommended configuration options to avoid security issues when deserializing untrusted data:
Can be used safely with default configuration:
The following libraries can be used safely with default configuration:
(JSON) - can be used safely as long as
option is not turned on
(JSON) - can be used safely as long
as polymorphism is not used (
(custom format) - can be used safely
as long as class registration is not turned
(YAML) - can be used safely
class isn't used (see
NOTE: because these versions are not available in Maven Central,
that can be used instead.
(JSON and XML) - can be used safely
as long as the allowlist and other security controls are not relaxed (
Requires configuration before can be used safely:
The following libraries require configuration options to be set before they can be used safely:
(JSON) - cannot be used safely unless
option is turned on, which disables
deserialization of any class (
Previous versions are not safe.
(JSON) - cannot be used safely since the use of
JSON allows deserialization of any class. Can only be used safely in following situations:
setting which turns off generic object deserialization
With a custom deserializer
controlling which classes get deserialized
(custom format) - cannot be used safely unless class registration is turned
which disables deserialization of any class (
NOTE: other wrappers exist around Kryo such as
, which may also have class registration
not required by default regardless of the underlying version of Kryo being used
(YAML) - cannot be used safely unless
org.yaml.snakeyaml.constructor.SafeConstructor
class is used, which disables
deserialization of any class (
Cannot be used safely:
The following libraries are either no longer maintained or cannot be used safely with untrusted input:
(XML) - appears to be abandoned with no commits since 2016
(JSON) - these versions allows deserialization of any class
XMLDecoder in the JDK
"close to impossible to securely deserialize Java objects in this format from untrusted inputs"
("Red Hat Defensive Coding Guide",
(JSON and XML) - these versions allows deserialization of any class (see
(YAML) - these versions allows deserialization of any class
Search the source code for the following terms:
JavaScriptTypeResolver
Look for any serializers where the type is set by a user controlled variable.
Search for the following base64 encoded content that starts with:
Search for content with the following text:
Microsoft has stated that the
type is dangerous and cannot be secured. As such, it should not be used. Full details are in the
BinaryFormatter security guide
Don't allow the datastream to define the type of object that the stream will be deserialized to. You can prevent this by for example using the
DataContractSerializer
is being used make sure the
is to be used then do not use it with a
JavaScriptTypeResolver
If you must deserialize data streams that define their own type, then restrict the types that are allowed to be deserialized. One should be aware that this is still risky as many native .Net types potentially dangerous in themselves. e.g.
objects that reference files actually on the server can when deserialized, change the properties of those files e.g. to read-only, creating a potential denial of service attack.
Even if you have limited the types that can be deserialized remember that some types have properties that are risky.
System.ComponentModel.DataAnnotations.ValidationException
, for example has a property
. if this type is the type allowed for deserialization then an attacker can set the
property to any object type they choose.
Attackers should be prevented from steering the type that will be instantiated. If this is possible then even
DataContractSerializer
can be subverted e.g.
// Action below is dangerous if the attacker can change the data in the database
GetTransactionTypeFromDatabase
DataContractJsonSerializer
Execution can occur within certain .Net types during deserialization. Creating a control such as the one shown below is ineffective.
//Check below is too late! Execution may have already occurred.
SomeDangerousObjectType
//generate warnings and dispose of suspectObject
it is possible to create a safer form of allow-list control using a custom
Try to keep up-to-date on known .Net insecure deserialization gadgets and pay special attention where such types can be created by your deserialization processes.
A deserializer can only instantiate types that it knows about
Try to keep any code that might create potential gadgets separate from any code that has internet connectivity. As an example
System.Windows.Data.ObjectDataProvider
used in WPF applications is a known gadget that allows arbitrary method invocation. It would be risky to have this a reference to this assembly in a REST service project that deserializes untrusted data.
Known .NET RCE Gadgets
System.Configuration.Install.AssemblyInstaller
System.Activities.Presentation.WorkflowDesigner
System.Windows.ResourceDictionary
System.Windows.Data.ObjectDataProvider
System.Windows.Forms.BindingSource
Microsoft.Exchange.Management.SystemManager.WinForms.ExchangeSettingsProvider
System.Data.DataViewManager, System.Xml.XmlDocument/XmlDataDocument
System.Management.Automation.PSObject
Language-Agnostic Methods for Deserializing Safely
Using Alternative Data Formats
A great reduction of risk is achieved by avoiding native (de)serialization formats. By switching to a pure data format like JSON or XML, you lessen the chance of custom deserialization logic being repurposed towards malicious ends.
Many applications rely on a
data-transfer object pattern
that involves creating a separate domain of objects for the explicit purpose data transfer. Of course, it's still possible that the application will make security mistakes after a pure data object is parsed.
Only Deserialize Signed Data
If the application knows before deserialization which messages will need to be processed, they could sign them as part of the serialization process. The application could then to choose not to deserialize any message which didn't have an authenticated signature.
Mitigation Tools/Libraries
Java secure deserialization library
SWAT - tool for creating allowlists
Java deserialization cheat sheet aimed at pen testers
A proof-of-concept tool for generating payloads that exploit unsafe Java object deserialization.
Java De-serialization toolkits
Java de-serialization tool
.Net payload generator
Java secure deserialization library
Serianalyzer is a static bytecode analyzer for deserialization
Android Java Deserialization Vulnerability Tester
Java Deserialization Scanner
Java-Deserialization-Cheat-Sheet
Deserialization of untrusted data
Java Deserialization Attacks - German OWASP Day 2016
AppSecCali 2015 - Marshalling Pickles
FoxGlove Security - Vulnerability Announcement
Java deserialization cheat sheet aimed at pen testers
A proof-of-concept tool for generating payloads that exploit unsafe Java object deserialization.
Java De-serialization toolkits
Java de-serialization tool
Java secure deserialization library
Serianalyzer is a static bytecode analyzer for deserialization
Android Java Deserialization Vulnerability Tester
Java Deserialization Scanner
Alvaro Muñoz: .NET Serialization: Detecting and defending vulnerable endpoints
James Forshaw - Black Hat USA 2012 - Are You My Type? Breaking .net Sandboxes Through Serialization
Jonathan Birch BlueHat v17 - Dangerous Contents - Securing .Net Deserialization
Alvaro Muñoz & Oleksandr Mirosh - Friday the 13th: Attacking JSON - AppSecUSA 2017
Exploiting Insecure Deserialization bugs found in the Wild (Python Pickles)